### Домашнее задание №14 **Оцениваемое (прежде чем приступить обязательно ознакомьтесь с [правилами оцениваемых домашних работ из этого файла](https://github.com/ancatmara/python-for-dh/blob/master/Classes/3/О_дз.md))**

При наличии причины можно обсудить дедлайн в индивидуальном порядке с @NickVeld (telegram).

Выполняется работа **строго** в репозитории **python-dh-hw** в файле **HW14.ipynb**, лежащем в корне репозитория: 

Прежде всего следует изучить [содержимое папки про третий семинар](https://github.com/ancatmara/python-for-dh/tree/master/Classes/3), все файлы кроме файла с семинара (там есть описание по установке необходимых программ для сдачи ДЗ ([Intro.ipynb](https://github.com/ancatmara/python-for-dh/blob/master/Classes/3/Intro.ipynb)) - это предписания по выполнению текущей и прошлых домашних работ, изучите их **предельно внимательно**. (В том числе пример сдачи).

Решите подзадачи:

#### 1. [3 балла] Preprocessing

Возьмите текст [текст](https://github.com/ancatmara/python-for-dh/tree/master/Homeworks/harms_mir.txt):

Необходимо написать функцию, которая считывает текст из файла и с помощью pymystem3 лемматизирует его.

Аргумент функции - путь к файлу (с названием файла). Возвращаемое значение - лемматизированный текст.

#### 2. [3 балла] Regular expression

В тексте полученном выше напечатайте количество предполагаемых замен и замените все слова, начинающиеся с п (независимо от регистра), содержащие л надо заменить на "глагол" без кавычек. При этом сочетание букв "пл", которое было расставлено по тексту создателями задания, нельзя заменять! 

Подсказка: Функции получения количества замен нет, надо понять откуда можно получить необходимое (материалов 4 (одна функция) и 10 семинара хватит для этого). В тексте подзадачи есть даже подсказка для одного способа - надо вначале посчитать количество, а потом заменять.

##### [+1 бонусный балл] Посмтройте свое регулярное выражение, так, чтобы ловились только глаголы (только для этого текста)

#### 3. [3 баллa] Старые добрые словари

Создать словарь, где ключами будут биграммы 'ее', 'её', 'но', 'ну', 'го', 'пл', а значениями — их количество во полученном тексте.

Напишите функцию, которая из словаря получает список пар "ключ: значение". С помощью этого словаря, сортировки и list comprehensions замените сами биграммы на их номера в этом списке так, чтобы получился список из пар "(место в отсортированном по количеству биграмм списке, сами количества этих биграмм)".

Аргумент - словарь. Возвращаемое значение - список вида "(номер в списке, количество)".

Пример (пусть функция называется `rating`): `rating({'го': 5, 'ее': 3, 'ну': 4}) =  [[1, 3], [2, 4], [3, 5]]`

Подсказка: чтобы отсортировать список нужным образом, надо объявить функцию `take_second`:

```
def take_second(x):
    return x[1]
```

и вызвать функцию `sorted(old_list, key=take_second)`, где `old_list` - ваш список пар. Вернется список пар, отсортированных по количеству биграмм, `key` - название именнованного аргумента, который говорит, как преобразовать элемент списка, чтобы можно было приступить к сортировке.

Напечатайте результат функции для вашего словаря.

#### 4. [1 балл] Visualisation

Постройте график/столбчатую диаграмму по полученному списку, полученному в предыдущем задании.

На оси `x` (горизонтальной) откладывается место в списке, на оси `y` (вертикальной) количество биграмм. Подпишите название диаграммы и оси. Раскрасьте график по своему усмотрению.

Самый легкий способ получить из списка пар координаты `x` и `y`: `x, y = zip(*my_list)`.

Вам надо всего лишь вместо `my_list` подставить в строку свое название листа, но если интересно, как это работает, то вот два примера (`f1` - функция 1, `f2` - функция 2, `a = [[1, 3], [2, 6]]`):

`f1(a)` - это то же самое, что `f1([[1, 3], [2, 6]])`, то есть у функции один аргумент - список.

`f2(*a)` - это то же самое, что `f2([1, 3], [2, 6])`, то есть у функции два аргумента - два маленьких списочка, то есть `*` превращает список в последовательность аргументов из содержимого этого списка.

Функция `zip` в свою очередь создает первый список из первых элементов всех маленьких списочков-аргументов, второй списочек из вторых  элементов всех маленьких списочков-аргументов. Так получаются нужные x и y.

P.S. По канону компьютерной лингвистики в первой задаче надо делать приведение к нижему регистру, и если вы это сделали/сделаете, то решение второй подзадачи будет проще. 

После решения задач необходимо выложить решение в Github. и проверить, что вы видите ваше решение по ссылке `https://github.com/*ваш username на github*/python-dh-hw/blob/master/HW14.ipynb`

В этом, как и в прошлых заданиях, коммиты следует делать через консольный интерфейс, а сообщения коммитов должны быть осмысленными (иначе в оцениваемых работах баллы будут снижаться, учим хорошему тону и полезному навыку).
